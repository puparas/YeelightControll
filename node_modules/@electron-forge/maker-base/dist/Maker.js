"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _which = _interopRequireDefault(require("which"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Maker {
  constructor(configFetcher = {}, providedPlatforms) {
    this.configFetcher = configFetcher;
    this.providedPlatforms = providedPlatforms;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "defaultPlatforms", void 0);

    _defineProperty(this, "requiredExternalBinaries", []);

    _defineProperty(this, "__isElectronForgeMaker", void 0);

    Object.defineProperty(this, '__isElectronForgeMaker', {
      value: true,
      enumerable: false,
      configurable: false
    });
  }

  get platforms() {
    if (this.providedPlatforms) return this.providedPlatforms;
    return this.defaultPlatforms;
  } // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
  //       v5 style functionality in the new API


  prepareConfig(targetArch) {
    if (typeof this.configFetcher === 'function') {
      this.config = this.configFetcher(targetArch);
    } else {
      this.config = this.configFetcher;
    }
  }
  /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */


  isSupportedOnCurrentPlatform() {
    if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
      throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
    }

    return true;
  }
  /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */


  async make(opts) {
    // eslint-disable-line max-len, @typescript-eslint/no-unused-vars
    if (this.make === Maker.prototype.make) {
      throw new Error(`Maker ${this.name} did not implement the make method`);
    }

    return [];
  }
  /**
   * Helpers
   */

  /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */


  async ensureDirectory(dir) {
    if (await _fsExtra.default.pathExists(dir)) {
      await _fsExtra.default.remove(dir);
    }

    return _fsExtra.default.mkdirs(dir);
  }
  /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */


  async ensureFile(file) {
    if (await _fsExtra.default.pathExists(file)) {
      await _fsExtra.default.remove(file);
    }

    await _fsExtra.default.mkdirs(_path.default.dirname(file));
  }
  /**
   * Checks if the specified binaries exist, which are required for the maker to be used.
   */


  externalBinariesExist() {
    return this.requiredExternalBinaries.every(binary => _which.default.sync(binary, {
      nothrow: true
    }) !== null);
  }
  /**
   * Throws an error if any of the binaries don't exist.
   */


  ensureExternalBinariesExist() {
    if (!this.externalBinariesExist()) {
      throw new Error(`Cannot make for ${this.name}, the following external binaries need to be installed: ${this.requiredExternalBinaries.join(', ')}`);
    }
  }
  /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */


  isInstalled(module) {
    try {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      require(module);

      return true;
    } catch (e) {
      // Package doesn't exist -- must not be installable on this platform
      return false;
    }
  }
  /**
   * Normalize the given semver-formatted version to a 4-part dot delimited version number without
   * prerelease information for use in Windows apps.
   */


  normalizeWindowsVersion(version) {
    const noPrerelease = version.replace(/-.*/, '');
    return `${noPrerelease}.0`;
  }

}

exports.default = Maker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJuYW1lcyI6WyJNYWtlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiZXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwicmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzIiwiZXZlcnkiLCJiaW5hcnkiLCJ3aGljaCIsInN5bmMiLCJub3Rocm93IiwiZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0Iiwiam9pbiIsImlzSW5zdGFsbGVkIiwibW9kdWxlIiwicmVxdWlyZSIsImUiLCJub3JtYWxpemVXaW5kb3dzVmVyc2lvbiIsInZlcnNpb24iLCJub1ByZXJlbGVhc2UiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7O0FBa0NlLE1BQWVBLEtBQWYsQ0FBK0M7QUFXNURDLEVBQUFBLFdBQVcsQ0FDREMsYUFBNkMsR0FBRyxFQUQvQyxFQUVDQyxpQkFGRCxFQUdUO0FBQUEsU0FGUUQsYUFFUixHQUZRQSxhQUVSO0FBQUEsU0FEVUMsaUJBQ1YsR0FEVUEsaUJBQ1Y7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUEsc0RBUDBDLEVBTzFDOztBQUFBOztBQUNBQyxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsSUFB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QUFHRCxPQUFPLENBQUNFLE9BQVIsQ0FBZ0IsS0FBaEIsRUFBdUIsRUFBdkIsQ0FBckI7QUFDQSxXQUFRLEdBQUVELFlBQWEsSUFBdkI7QUFDRDs7QUFySTJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRm9yZ2VBcmNoLCBGb3JnZUNvbmZpZywgRm9yZ2VQbGF0Zm9ybSwgSUZvcmdlTWFrZXIsXG59IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHdoaWNoIGZyb20gJ3doaWNoJztcblxuZXhwb3J0IGludGVyZmFjZSBNYWtlck9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSBwYWNrYWdlZCBFbGVjdHJvbiBhcHBsaWNhdGlvblxuICAgKi9cbiAgZGlyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IHlvdSBzaG91bGQgcHV0IGFsbCB5b3VyIGFydGlmYWN0cyBpbiAocG90ZW50aWFsbHkgaW4gc3ViIGZvbGRlcnMpXG4gICAqIE5PVEU6IHRoaXMgZGlyZWN0b3J5IGlzIG5vdCBndWFydW50ZWVkIHRvIGFscmVhZHkgZXhpc3RcbiAgICovXG4gIG1ha2VEaXI6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBodW1hbiBmcmllbmRseSBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBhcHBOYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtIHlvdSBzaG91bGQgbWFrZSBmb3JcbiAgICovXG4gIHRhcmdldFBsYXRmb3JtOiBGb3JnZVBsYXRmb3JtO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmUgeW91IHNob3VsZCBtYWtlIGZvclxuICAgKi9cbiAgdGFyZ2V0QXJjaDogRm9yZ2VBcmNoO1xuICAvKipcbiAgICogRnVsbHkgcmVzb2x2ZWQgZm9yZ2UgY29uZmlndXJhdGlvbiwgeW91IHNob3VsZG4ndCByZWFsbHkgbmVlZCB0aGlzXG4gICAqL1xuICBmb3JnZUNvbmZpZzogRm9yZ2VDb25maWc7XG4gIC8qKlxuICAgKiBUaGUgYXBwbGljYXRpb25zIHBhY2thZ2UuanNvbiBmaWxlXG4gICAqL1xuICBwYWNrYWdlSlNPTjogYW55O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBNYWtlcjxDPiBpbXBsZW1lbnRzIElGb3JnZU1ha2VyIHtcbiAgcHVibGljIGNvbmZpZyE6IEM7XG5cbiAgcHVibGljIGFic3RyYWN0IG5hbWU6IHN0cmluZztcblxuICBwdWJsaWMgYWJzdHJhY3QgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdO1xuXG4gIHB1YmxpYyByZXF1aXJlZEV4dGVybmFsQmluYXJpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgX19pc0VsZWN0cm9uRm9yZ2VNYWtlciE6IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb25maWdGZXRjaGVyOiAoQyB8ICgoYXJjaDogRm9yZ2VBcmNoKSA9PiBDKSkgPSB7fSBhcyBDLFxuICAgIHByb3RlY3RlZCBwcm92aWRlZFBsYXRmb3Jtcz86IEZvcmdlUGxhdGZvcm1bXSxcbiAgKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyJywge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm1zKCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVkUGxhdGZvcm1zKSByZXR1cm4gdGhpcy5wcm92aWRlZFBsYXRmb3JtcztcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UGxhdGZvcm1zO1xuICB9XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMsIGl0IGlzIGFuIGV5ZS1zb3JlIGFuZCBpcyBhIG5hc3R5IGhhY2sgdG8gcHJvdmlkZSBmb3JnZVxuICAvLyAgICAgICB2NSBzdHlsZSBmdW5jdGlvbmFsaXR5IGluIHRoZSBuZXcgQVBJXG4gIHByZXBhcmVDb25maWcodGFyZ2V0QXJjaDogRm9yZ2VBcmNoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZ0ZldGNoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY29uZmlnID0gKHRoaXMuY29uZmlnRmV0Y2hlciBhcyBhbnkgYXMgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpKSh0YXJnZXRBcmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbmZpZ0ZldGNoZXIgYXMgQztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZXJzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kIGFuZCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogdGhpcyBtYWtlciBjYW4gYmUgcnVuIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLiAgTm9ybWFsbHkgdGhpcyBpcyBqdXN0IGEgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgKiBjaGVjayBidXQgaXQgY2FuIGJlIGEgZGVlcGVyIGNoZWNrIGZvciBkZXBlbmRlbmNpZXMgbGlrZSBmYWtlLXJvb3Qgb3Igb3RoZXJcbiAgICogcmVxdWlyZWQgZXh0ZXJuYWwgYnVpbGQgdG9vbHMuXG4gICAqXG4gICAqIElmIHRoZSBpc3N1ZSBpcyBhIG1pc3NpbmcgZGVwZW5kZW5jeSB5b3Ugc2hvdWxkIGxvZyBvdXQgYSBIRUxQRlVMIGVycm9yIG1lc3NhZ2VcbiAgICogdGVsbGluZyB0aGUgZGV2ZWxvcGVyIGV4YWN0bHkgd2hhdCBpcyBtaXNzaW5nIGFuZCBpZiBwb3NzaWJsZSBob3cgdG8gZ2V0IGl0LlxuICAgKi9cbiAgaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtID09PSBNYWtlci5wcm90b3R5cGUuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWtlciAke3RoaXMubmFtZX0gZGlkIG5vdCBpbXBsZW1lbnQgdGhlIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0gbWV0aG9kYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIGFic29sdXRlIHBhdGhzXG4gICAqIHRvIHRoZSBhcnRpZmFjdHMgZ2VuZXJhdGVkIGJ5IHlvdXIgbWFrZXJcbiAgICovXG4gIGFzeW5jIG1ha2Uob3B0czogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGlmICh0aGlzLm1ha2UgPT09IE1ha2VyLnByb3RvdHlwZS5tYWtlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ha2VyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgbWFrZSBtZXRob2RgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGZvcmNlZCB0byBiZSBlbXB0eS5cbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzIGl0IGlzIGRlbGV0ZWQgYW5kIHJlY3JlYXRlZCwgdGhpc1xuICAgKiBpcyBhIGRlc3RydWN0aXZlIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRGlyZWN0b3J5KGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZGlyKSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGRpcik7XG4gICAgfVxuICAgIHJldHVybiBmcy5ta2RpcnMoZGlyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBwYXRoIHRvIHRoZSBmaWxlIGV4aXN0cyBhbmQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBpdCBpcyBkZWxldGVkIGFuZCB0aGUgcGF0aCBjcmVhdGVkXG4gICAqL1xuICBhc3luYyBlbnN1cmVGaWxlKGZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGUpKSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoZmlsZSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlycyhwYXRoLmRpcm5hbWUoZmlsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGJpbmFyaWVzIGV4aXN0LCB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIHRoZSBtYWtlciB0byBiZSB1c2VkLlxuICAgKi9cbiAgZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5ldmVyeShcbiAgICAgIChiaW5hcnkpID0+IHdoaWNoLnN5bmMoYmluYXJ5LCB7IG5vdGhyb3c6IHRydWUgfSkgIT09IG51bGwsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBiaW5hcmllcyBkb24ndCBleGlzdC5cbiAgICovXG4gIGVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpIHtcbiAgICBpZiAoIXRoaXMuZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1ha2UgZm9yICR7dGhpcy5uYW1lfSwgdGhlIGZvbGxvd2luZyBleHRlcm5hbCBiaW5hcmllcyBuZWVkIHRvIGJlIGluc3RhbGxlZDogJHt0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZHVsZSBpcyBpbnN0YWxsZWQsIHVzZWQgZm9yIHRlc3RpbmcgaWYgb3B0aW9uYWwgZGVwZW5kZW5jaWVzXG4gICAqIGFyZSBpbnN0YWxsZWQgb3Igbm90XG4gICAqL1xuICBpc0luc3RhbGxlZChtb2R1bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgIHJlcXVpcmUobW9kdWxlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFBhY2thZ2UgZG9lc24ndCBleGlzdCAtLSBtdXN0IG5vdCBiZSBpbnN0YWxsYWJsZSBvbiB0aGlzIHBsYXRmb3JtXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gc2VtdmVyLWZvcm1hdHRlZCB2ZXJzaW9uIHRvIGEgNC1wYXJ0IGRvdCBkZWxpbWl0ZWQgdmVyc2lvbiBudW1iZXIgd2l0aG91dFxuICAgKiBwcmVyZWxlYXNlIGluZm9ybWF0aW9uIGZvciB1c2UgaW4gV2luZG93cyBhcHBzLlxuICAgKi9cbiAgbm9ybWFsaXplV2luZG93c1ZlcnNpb24odmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBub1ByZXJlbGVhc2UgPSB2ZXJzaW9uLnJlcGxhY2UoLy0uKi8sICcnKTtcbiAgICByZXR1cm4gYCR7bm9QcmVyZWxlYXNlfS4wYDtcbiAgfVxufVxuIl19